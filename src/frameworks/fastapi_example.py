# Импортируем необходимые модули из FastAPI
from fastapi import FastAPI, Path, Query, HTTPException
import asyncio  # Для примера асинхронной работы

# Создаем экземпляр приложения FastAPI с описанием, заголовком и версией API
app = FastAPI(
    title="Пример API на FastAPI",
    description="Этот API демонстрирует несколько примеров: работа с путями, параметрами, валидация входных данных и обработка ошибок.",
    version="1.0.0"
)


# ----------------------------------------------------------------
# Пример 1: Простой эндпоинт, возвращающий приветственное сообщение
# ----------------------------------------------------------------
@app.get("/")
async def read_root():
    """
    Обработчик корневого эндпоинта.
    Возвращает JSON-ответ с приветственным сообщением.
    """
    return {"message": "Добро пожаловать в FastAPI!"}


# ----------------------------------------------------------------
# Пример 2: Эндпоинт с параметром пути для получения информации о пользователе
# ----------------------------------------------------------------
@app.get("/users/{user_id}")
async def read_user(
        # Параметр 'user_id' извлекается из URL. Path позволяет задать дополнительные пояснения.
        user_id: int = Path(..., description="Идентификатор пользователя (целое число)")
):
    """
    Обработчик запроса для получения информации о пользователе.
    Параметры:
      - user_id: Идентификатор пользователя, передаваемый в URL.
    Возвращает JSON с данными пользователя.
    """
    # В реальном приложении здесь можно было бы подключаться к базе данных для поиска пользователя.
    return {"user_id": user_id, "name": f"Пользователь {user_id}"}


# ----------------------------------------------------------------
# Пример 3: Эндпоинт с параметрами запроса для пагинации пользователей
# ----------------------------------------------------------------
@app.get("/users")
async def get_users(
        # Query используется для параметров, передаваемых в строке запроса.
        skip: int = Query(0, description="Количество записей для пропуска (например, для пагинации)"),
        limit: int = Query(10, description="Максимальное количество возвращаемых записей")
):
    """
    Обработчик запроса для получения списка пользователей с поддержкой пагинации.
    Параметры:
      - skip: количество записей, которые нужно пропустить.
      - limit: максимальное число возвращаемых записей.
    Возвращает JSON со списком пользователей.
    """
    # Здесь создаем список пользователей для демонстрации; в реальном проекте данные можно брать из БД.
    users = [{"user_id": i, "name": f"Пользователь {i}"} for i in range(skip, skip + limit)]
    return {"users": users}


# ----------------------------------------------------------------
# Пример 4: Эндпоинт с обработкой ошибок с использованием HTTPException
# ----------------------------------------------------------------
@app.get("/items/{item_id}")
async def read_item(item_id: int):
    """
    Обработчик запроса для получения информации о товаре.
    Если значение item_id меньше или равно 0, генерируется HTTPException с кодом 404.
    Параметры:
      - item_id: Идентификатор товара.
    Возвращает JSON с данными товара или ошибку, если товар не найден.
    """
    # Здесь для демонстрации проверяем, валидно ли значение item_id.
    if item_id <= 0:
        # HTTPException генерирует ошибку с нужным кодом и сообщением, которая автоматически преобразуется в корректный HTTP-ответ.
        raise HTTPException(status_code=404, detail="Товар не найден")
    return {"item_id": item_id, "description": f"Описание товара с идентификатором {item_id}"}


# ----------------------------------------------------------------
# Пример 5: Демонстрация асинхронного выполнения
# ----------------------------------------------------------------
@app.get("/async-demo")
async def async_demo():
    """
    Асинхронный обработчик, демонстрирующий выполнение длительной операции.
    Здесь используется asyncio.sleep для имитации долгой операции.
    Возвращает JSON-сообщение по завершении операции.
    """
    # Симуляция задержки в 1 секунду (например, длительная операция или запрос к внешнему API).
    await asyncio.sleep(1)
    return {"status": "Операция завершена успешно"}


if __name__ == "__main__":
    import uvicorn

    # Запускаем сервер на localhost:8000
    uvicorn.run(app, host="127.0.0.1", port=8000)
